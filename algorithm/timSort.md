# Tim Sort



## 시간 복잡도에 영향을 미치는 요소

- 시간 복잡도가 O(nlogn)이라는 말은 실제 동작이 C * nlogn + *α* 이라는 뜻임
- 따라서 무시할 수 있는 수준인 α를 제외하면, C라는 상수에 따라 실제 동작 시간에 차이를 보임
- C 상수에 큰 영향을 끼치는 요소로 '알고리즘이 <b>참조 지역성(Locality of reference)</b> 원리를 얼마나 잘 만족하는가'가 있음



## 참조 지역성(Locality of reference)

- CPU가 미래에 원하는 데이터를 예측하여 속도가 빠른 장치인 캐시 메모리에 담아 놓는데, 이때의 예측률을 높이기 위해 사용하는 원리
- 최근에 참조한 메모리나 그 메모리와 인접한 메모리를 다시 참조할 확률이 높다는 이론을 기반으로 캐시 메모리에 담아 놓는 것
- 메모리를 연속으로 읽는 작업은 캐시 메모리에서 읽어오기에 빠르지만, 무작위로 읽는 작업은 메인 메모리에서 읽어오기에 속도의 차이가 있음
- Heap sort는 부모 노드나 자식 노드의 index를 반복적으로 비교하므로 캐시 메모리에서 예측하기 힘든 참조 지역성이 좋지 않은 알고리즘. 반면 Merge sort는 인접한 덩어리를 병합하므로, Quick sort는 pivot을 정해 주위의 값을 정렬하므로 참조 지역성이 좋음



## Tim sort 기본 원리

> - Insertion sort와 Merge sort를 결합한 알고리즘
> - 안정 정렬인 두 알고리즘 결합하여 <b>안정 정렬</b>
> - 평균 O(nlogn)로 정렬 속도가 <b>빠름</b>
> - 추가 메모리는 사용하지만 <b>Merge sort에 비해 적은 메모리</b>를 사용하여 단점 보완
> - 무작위적이지 않은 실생활 데이터의 특성(오름차순 또는 내림차순으로 정렬되어 있는 데이터들이 많을 수 있음)을 고려하여 최적화



- Merge sort의 단점 보완(<b>시간 복잡도 개선</b>)

  > 분할 -> 정복에서 merge는 최소 단위로 분할하지만, 아래처럼 최대한의 run 구간을 만들어 insertion sort

  - Insertion sort의 방법을 통해 merge sort의 단점 보완. 상수 C에 대해 n이 충분히 작다면 O(nlogn) 알고리즘 중 가장 C가 작다는 quick sort보다도 빠르므로, 전체를 작은 덩어리로 잘라 각각의 덩어리를 Insertion sort로 병합하면 더 빠르게 됨

    - 2**x 개씩 잘라서 각각을 Insertion sort로 정렬하면 Merge sort 보다 x개의 병합 동작이 생략됨

    - x의 값을 크게 하기 위해, `run`이라는 덩어리를 만듦. 첫 두 원소의 대소관계로 덩어리를 오름 또는 내림(내림은 마지막에 오름으로 뒤집음)으로 정의하여 2**x개까지는 Insertion sort를 진행하고, 그 이후의 원소에 대해서 가능한 크게 run을 만듦

    - Tim sort에서 사용하는 Insertion sort는 Binary Insertion sort

      (앞의 원소들이 모두 정렬되어 있다는 전제로 이분탐색하여 삽입할 위치를 결정할 때 O(n)이 아닌 O(logn) 소요)

    - 위 과정을 통해 병합할 (정렬된)run을 생성!

    

- Merge sort의 단점 보완(<b>공간 복잡도 개선</b>)

  - merge sort처럼 비슷한 크기의 덩어리와 병합해 효율성을 증대시키기 위해, 크기가 제각각인 run을 비슷한 크기의 run 단위로 병합하는 사전작업을 진행 >> 가장 효율적인 방법으로 병합할 두 run을 알아냄
    - run이 만들어질 때마다 스택에 담아 run들을 크기가 비슷하게 만듬
  - 두 개의 run 중 크기가 더 작은 run을 복사하여, 시작 부분부터 크기 비교를 시작해 앞(또는 뒤)에서부터 채우면서 병합 진행 / (A, B run이 있을 때 A가 더 작으면 A, B가 더 작으면 B 복사)
  - 최악의 경우 O(n/2)
  - <small>여기서 더 최적화를 한다면, run A, B 병합 전에 이미 정렬되어 있어 병합을 수행할 필요가 없는 구간을 계산하여, 병합이 필요한 부분만 복사해 메모리 절약</small>
  - Galloping
    - '한 run을 계속해서 참조할 경우가 많지 않을까'라는 무작위적이지 않은 실생활 데이터 특성을 이용해 Galloping mode일 경우 하나의 run을 빠르게 참조하도록 동작
    - 2**k 만큼씩 뛰어넘으면서 가리키고 있는 값과 비교할 key값의 대소비교를 통해 빠르게 탐색

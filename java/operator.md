# Operator(연산자)



## 연산자와 피연산자

- 연산자(operator) : 연산을 수행하는 기호(+, -, *, / 등)
- 피연산자(operand) : 연산자의 작업 대상(변수, 상수, 리터럴, 수식)



## 연산자의 종류

| 종류        | 연산자          |
| ----------- | --------------- |
| 산술 연산자 | + - * / % << >> |
| 비교 연산자 | > < >= <= == != |
| 논리 연산자 | && \|\| ! & \| ^ ~ |
|대입 연산자|=|
|증감 연산자| ++ --|
|기타|(type) ?: instanceof|

##### 증감연산자

- 피연산자에 저장된 값을 1증가 또는 감소

- 피연산자는 정수와 실수 모두 가능하지만, 상수는 값을 변경시킬 수 없으므로 불가능

- 전위 vs 후위

  ```java
  j = ++i;  // 전위, 값이 참조되기 전 증감, ++i 이후 j = i
  j = i++;  // 후위, 값이 참조된 후 증감, j = i 이후 i++
  ```



##### 등가비교 연산자

- ==, !=
- `==` vs `equals`
  - `==`은 참조하고 있는 주소값을 비교, `equals()` 함수는 대상의 값을 직접 비교



##### 효율적인 연산(short circuit evaluation)

- OR 연산의 경우 한 쪽만 참이면 전체 연산 결과가 참이므로 좌측 피연산자가 참일 경우 이후 피연산자들은 평가하지 않음
- AND 연산의 경우도 한 쪽이 거짓이면 전체 연산 결과가 거짓이므로 좌측 피연산자가 거짓일 경우 이후 피연산자들은 평가하지 않음
- 따라서 AND, OR 연산의 경우 거짓이거나 참일 확률이 높은 피연산자를 왼쪽에 놓아야 더 빠른 연산 결과를 얻을수 있음



##### 비트 연산자

- |(OR연산자) : `1 | 0 => 1`

  - 주로 특정 비트의 값 변경 시 사용
  - 0xAB | 0xF = 0xAF

- &(AND연산자) :  `1 & 1 => 1`

  - 주로 특정 비트의 값을 뽑아낼 때 사용
  - 0xAB & 0xF = 0xB

- ^(XOR연산자) : `1 && 0 => 1`

  - XOR 연산 2n번 반복 시 같은 값으로 돌아오는 특징이 있어 간단한 암호화에 사용

- ~(비트 전환 연산자)

  - 피연산자를 2진수로 표현했을 때 0은 1로, 1은 0으로 변환

  - 부호 있는 타입의 피연산자는 부호가 반대로 변경, 즉 '1의 보수'를 얻음

    \* 보수는 두 수의 합이 진법의 밑수(n)가 되게 하는 수. 즉 비트 전환이 완료된 뒤 1을 더하면 해당 2진수를 정수 변환하였을 때 부호만 다른 수가 됨. 결론적으로 p = 10일 때, ~p+1은 -10이 됨.

- \>> <<(shift 연산자)

  - 피연산자를 2진수로 표현했을 때 각 자리를 왼쪽 또는 오른쪽으로 2칸 이동시키는 것
  - 이 때 저장 범위를 벗어난 값들은 버려지고 나머지는 0으로 채워짐. 단, 피연산자가 음수인 경우 >> shift 시 부호를 유지하기 위해 빈 값은 1로 채워짐
  - 2진수를 각 2칸 이동시키는 것이기 때문에 `x << n 또는 x >> n` 는 `x * 2^n 또는 x / 2^n`. 단, 저장 범위를 벗어나면 해당 저장 범위(예를 들어 32 bit)를 벗어나면 해당 bit 수로 나눈 나머지 만큼만 이동됨.
  - 비트 연산은 프로그램의 속도에 영향을 미치므로, 가독성 보다는 속도가 중요할 때 주로 사용


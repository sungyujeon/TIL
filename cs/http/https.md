# HTTPS

출처: [[만화](https://howhttps.works/why-do-we-need-https/)]

## 1. HTTPS가 필요한 3가지 이유

### 1. Privacy

- 남이 중간에서 내가 보내는 메시지를 엿듣지 못하게 함

### 2. Integrity

- 남이 중간에서 내가 보내는 메시지를 조작할 수 없게 함

### 3. Identification

- 메세지에 첨부된 전자 서명으로 메세지를 보내는 사람을 식별할 수 있음(서버 등)
- 브라우징을 할때에는 내가 방문하는 곳이 내가 생각하는 사이트가 맞도록 보장해줌
- HTTPS는 SSL certificate를 통해서 정확히 내가 생각하는 그 상대와 연결되는 것을 보장해줌
  - 이 증명서(certificate)는 정당한 인증기관(Certificate Authority; CA)로부터 발급받음

## 2. 대칭 키와 공개 키 알고리즘 (두 종류의 암호화)

HTTPS가 privacy, integrity, identification을 보장하는 메커니즘을 "encryption"이라고 부름(암호화)

### 대칭 키 알고리즘

- 메시지를 암호화하고 해독하는 데에 쓰이는 키가 오직 **한 개**임
- A가 이 key를 활용해 메시지를 암호화한 후 B에게 보내면 B는 A가 암호화할 때 사용한 것과 똑같은 key로 해당 암호를 해독할 수 있음.
  - 때문에 맞는 key를 가진 사람이 아니면 메시지를 확인할 수 없음
- 이 방식에서는 key가 유출되지 않도록 하는 것이 중요함
- 이 방식의 어려움 중 하나는 key를 공유하는 것이 어렵다는 것임
  - 이러한 불편함이 **비대칭 key를** 사용하도록 함

### 비대칭 키 알고리즘

- key가 2개임.
  - 하나는 공개 키
  - 다른 하나는 비밀 키
- 두 개의 키가 하나의 쌍으로 작동함
- 누구에게든 공개 키를 공유해도 됌(plain text로 공유해도 무방)
- 이렇게 공개된 공개 키를 통해 브라우저는 메시지를 암호화 해서 전송함
- 공개 키를 통해서 암호화된 메시지는 오직 그 공개 키의 페어인 비밀 키를 가지고 있는 사람만 해독할 수 있음
- 이 방식은, privacy 뿐만 아니라 identification에도 좋음 - 두 개의 키를 가지고 있는 사람만이 메시지를 열어볼 수 있다는 것을 알기 때문

## 3. 4-way HANDSHAKE

HTTPS를 통해 웹사이트에 접속하면 우리는 주소창에 있는 자물쇠 모양을 확인할 수 있다. 이는 브라우저와 서버가 안전한 방식으로 통신하기 위한 협상을 마쳤다는 표시이다. 이 협상은 굉장히 빠르게 이루어지며, 다음과 같은 과정을 포함한다.

### 1. 브라우저 → 서버

- SSL/TLS 버젼들과 암호화 알고리즘(fancy word: cipher suite)의 리스트를 보낸다.

### 2. 서버 → 브라우저

- 서버는 브라우저가 보낸 SSL/TLS 버젼들과 암호화 알고리즘 중 선호하는 것을 선택한다.
- 서버는 인증 기관(CA)에서 발급한 증명서(certificate)를 브라우저에게 보내는데, 그 안에는 공개 키가 들어가 있다. 서버는 이 증명서를 통해서 브라우저에게 자신을 인증할 수 있다

### 3. 브라우저 → 서버

- 서버가 보낸 인증서를 보고 서버를 믿을 수 있다고 판단함
- 서버가 보낸 공개 키를 통해서 통신에 사용할 대칭 키를 암호화해서 서버에게 보냄

### 4. 서버 → 브라우저 → 서버 → 브라우저...

- 서버는 브라우저가 보낸 암호를 본인이 보낸 공개 키에 대응하는 본인만이 가진 비밀 키를 이용해서 해독 ⇒ 대칭 키 얻음

### HANDSHAKE 완료

- 이제 서버와 브라우저 간의 HANDSHAKE가 완료된 것
- 서버와 브라우저는 앞으로 이 대칭 키를 이용해서 메세지를 암호화하고 해독함.

## 4. HTTPS, SSL, TLS라는 용어들의 차이점

### HTTPS

- HyperText Transfer Protocol Secure
- HTTP에서 보안이 강화된 프로토콜
- HTTP는 클라이언트와 서버가 정보를 주고 받기 위한 프로토콜인데,
- 주고받는 데이터가 SSL/TLS로 암호화되면 이제 이 프로토콜을 HTTPS라고 부름
- 즉, HTTPS는 단지 SSL/TLS를 통해서 데이털르 암호화하는 HTTP 프로토콜일 뿐임

### SSL

- Secure Sockets Layer
- Netscape에 의해 만들어진 프로토콜
- 이후 Netscape는 SSL 프로토콜에 대한 통제권을 IETF(Internet Engineering Task Force)에 넘김
- SSL은 1990년대 초반에 생긴 오리지널이지만, 현재는 deprecated 된 프로토콜임

### TLS

- 1999년 SSL이 TLS로 이름이 바뀜
- Transport Layer Security
- 2018년 승인된 TLS 1.3 버젼은 보안에 있어서 굉장히 발전했음

## 5. Certificate Authorities(인증 기관): HTTPS가 작동하는 방식은?

### CA의 3가지 주요 목적

1. 인증서 발행
2. 인증서 보유자의 신원을 확인해줌
3. 인증서가 유효하다는 증거를 제공해 줌

### CA가 되기 위한 과정

- 까다로움
- root store에 받아들여져야 함
- roo store는 신뢰할 수 있는 CA들의 데이터베이스임
- Apple, Windows, Mozilla는 자기들의 root sotre를 가지고 있음. 그리고 이것들은 우리 컴퓨터나 기기에 미리 깔려있음

### 3가지 인증서 종류

1. Domain Validated
   - 이 인증서는 단지 도메인만을 확인해줄 뿐임
2. Organization Validated
   - 이 인증서는 비준(확인)과 organization의 수기 비준을 요구한다.
3. Entended Validation
   - 이 인증서는 비즈니스에 대한 굉장히 자세한 비준을 요구한다.

### 인증서가 validate 되는 과정

- CA는 브라우저의 root store에 있는 자신의 root 인증서로 싸인을 해서 mid 인증서를 발행한다.
- 대부분 이렇게 root 인증서로 싸인한 인증서는 '중간의' 인증서다
- root 인증서는 각각의 기기에 설치되어 있기 때문에, 만약 예기치 못한일로 root 인증서가 위태로워질 경우 중간의 인증서를 폐기하기가 더 쉽다.

1. 브라우저는 서버에 HTTPS를 통해서 연결하고, 인증서를 다운받는다.
2. 그 인증서는 root 인증서가 아니다. 따라서 브라우저는 그 인증서에 싸인을 할 때 쓰인 인증서를 다운받는다.
3. 하지만 이 인증서도 root 인증서가 아니다. 따라서 브라우저는 이 중간 인증서에 싸인한 인증서를 다시 한 번 찾아보게 된다. (root 인증서). 이제 전체적인 인증서 연쇄가 신뢰되었고, 따라서 이제 그 서버 또한 신뢰할 수 있게 된다.

만약 마지막 인증서가 root 인증서가 아니고, 더 이상 다운받을 인증서가 없다면, 인증서의 연쇄는 신뢰받지 못한다.

### CA를 이용하는 이유

왜 직접 싸인하지 않고 CA를 이용하는 것일까? 직접 싸인한 인증서는 인증 기관에 의해서 생성된 인증서와 같은 수준의 암호화를 제공하며, 다른 사람이 데이터를 탈취할 수 없고, 무료이기까지 한데 말이다.

⇒ 대부분의 브라우저가 인증서가 신뢰로운 기관에 의해 발행된 것인지 확인하기 때문이다.

- 따라서 그렇지 않은 경우 브라우저는 이에 대해 인증서가 신뢰롭지 못하다고 경고한다.

직접 싸인한 인증서는 테스트 용도나 인트라넷 용도로는 유용하지만, 공적인 사이트에서 사용하는 것은 지양해야 한다.

직접 싸인한 인증서는 자기 자신을 믿어도 된다면서 위조할 수 있다. 반면, 신뢰로운 인증서는 인증 기관이 확인한 것이기 때문에 더 믿음이 간다.